(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("reflect-metadata"), require("inversify"), require("emittery"), require("xmldom")) : typeof define === "function" && define.amd ? define([ "exports", "reflect-metadata", "inversify", "emittery", "xmldom" ], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, 
    factory(global.BloomreachSpaSdk = {}, null, global.inversify, global.emittery, global.xmldom));
})(this, (function(exports, reflectMetadata, inversify, emittery, xmldom) {
    "use strict";
    function _extends() {
        _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        };
        return _extends.apply(this, arguments);
    }
    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function(target, key) {
            decorator(target, key, paramIndex);
        };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }));
        }
        return new (P || (P = Promise))((function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        }));
    }
    function appendSearchParams(url, params) {
        const {hash, origin, pathname, searchParams} = parseUrl(url);
        return buildUrl({
            hash,
            origin,
            pathname,
            searchParams: mergeSearchParams(searchParams, params)
        });
    }
    function buildUrl(url) {
        var _a, _b, _c, _d, _e, _f, _g;
        const searchParams = (_b = (_a = url.searchParams) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "";
        const search = (_c = url.search) !== null && _c !== void 0 ? _c : `${searchParams && `?${searchParams}`}`;
        const path = (_d = url.path) !== null && _d !== void 0 ? _d : `${(_e = url.pathname) !== null && _e !== void 0 ? _e : ""}${search}${(_f = url.hash) !== null && _f !== void 0 ? _f : ""}`;
        return `${(_g = url.origin) !== null && _g !== void 0 ? _g : ""}${path}`;
    }
    function extractSearchParams(url, params) {
        const {hash, origin, pathname, searchParams} = parseUrl(url);
        const extracted = new URLSearchParams;
        params.forEach((param => {
            if (searchParams.has(param)) {
                extracted.set(param, searchParams.get(param));
                searchParams.delete(param);
            }
        }));
        return {
            searchParams: extracted,
            url: buildUrl({
                hash,
                origin,
                pathname,
                searchParams
            })
        };
    }
    function isAbsoluteUrl(url) {
        const {origin, pathname} = parseUrl(url);
        return !!origin || pathname.startsWith("/");
    }
    function isMatchedOrigin(origin, baseOrigin) {
        const [schema, host = ""] = origin.split("//", 2);
        const [baseSchema, baseHost = ""] = baseOrigin.split("//", 2);
        return !baseOrigin || !origin || (!schema || !baseSchema || schema === baseSchema) && baseHost === host;
    }
    function isMatchedPathname(pathname, basePathname) {
        return !basePathname || pathname.startsWith(basePathname);
    }
    function isMatchedQuery(search, baseSearch) {
        let match = true;
        baseSearch.forEach(((value, key) => {
            match = match && (!value && search.has(key) || search.getAll(key).includes(value));
        }));
        return match;
    }
    function isMatched(link, base = "") {
        const linkUrl = parseUrl(link);
        const baseUrl = parseUrl(base);
        return isMatchedOrigin(linkUrl.origin, baseUrl.origin) && isMatchedPathname(linkUrl.pathname, baseUrl.pathname) && isMatchedQuery(linkUrl.searchParams, baseUrl.searchParams);
    }
    function mergeSearchParams(params, ...rest) {
        const result = new URLSearchParams(params);
        rest.forEach((params => params.forEach(((value, key) => result.set(key, value)))));
        return result;
    }
    function parseUrl(url) {
        const parsedUrl = url ? new URL(url, "http://example.com") : {};
        const {hash = "", search = "", searchParams = new URLSearchParams} = parsedUrl;
        let origin = url.substring(0, url.length - search.length - hash.length);
        let {pathname = ""} = parsedUrl;
        if (!origin.endsWith(pathname)) {
            pathname = pathname.substring(1);
        }
        origin = origin.substring(0, origin.length - pathname.length);
        return {
            hash,
            origin,
            pathname,
            search,
            searchParams,
            path: `${pathname}${search}${hash}`
        };
    }
    function resolveUrl(url, base) {
        const baseUrl = parseUrl(base);
        const sourceUrl = parseUrl(url);
        const pathname = sourceUrl.pathname.startsWith("/") ? sourceUrl.pathname : `${baseUrl.pathname}${baseUrl.pathname.endsWith("/") || !sourceUrl.pathname ? "" : "/"}${sourceUrl.pathname}`;
        return buildUrl({
            pathname,
            hash: sourceUrl.hash || baseUrl.hash,
            origin: sourceUrl.origin || baseUrl.origin,
            searchParams: mergeSearchParams(baseUrl.searchParams, sourceUrl.searchParams)
        });
    }
    const UrlBuilderOptionsToken = Symbol.for("UrlBuilderOptionsToken");
    const UrlBuilderService = Symbol.for("UrlBuilderService");
    let UrlBuilderImpl = class UrlBuilderImpl {
        constructor(options) {
            var _a, _b;
            this.endpoint = parseUrl((_a = options.endpoint) !== null && _a !== void 0 ? _a : "");
            this.baseUrl = parseUrl((_b = options.baseUrl) !== null && _b !== void 0 ? _b : "");
        }
        getApiUrl(link) {
            const {pathname, searchParams} = parseUrl(link);
            if (this.baseUrl.pathname && !pathname.startsWith(this.baseUrl.pathname)) {
                throw new Error(`The path "${pathname}" does not start with the base path "${this.baseUrl.pathname}".`);
            }
            const route = pathname.substring(this.baseUrl.pathname.length);
            return buildUrl({
                origin: this.endpoint.origin,
                pathname: `${this.endpoint.pathname}${route}`,
                searchParams: mergeSearchParams(searchParams, this.endpoint.searchParams)
            });
        }
        getSpaUrl(link) {
            const {hash, pathname, searchParams} = parseUrl(link);
            const route = !pathname.startsWith("/") && !this.baseUrl.pathname ? `/${pathname}` : pathname;
            return buildUrl({
                origin: this.baseUrl.origin,
                pathname: `${this.baseUrl.pathname}${route}`,
                searchParams: mergeSearchParams(searchParams, this.baseUrl.searchParams),
                hash: hash || this.baseUrl.hash
            });
        }
    };
    UrlBuilderImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(UrlBuilderOptionsToken)), __metadata("design:paramtypes", [ Object ]) ], UrlBuilderImpl);
    function UrlModule() {
        return new inversify.ContainerModule((bind => {
            bind(UrlBuilderService).to(UrlBuilderImpl).inSingletonScope();
        }));
    }
    const DEFAULT_API_BASE_URL = "/resourceapi";
    const DEFAULT_SPA_BASE_URL = "";
    let UrlBuilderImpl$1 = class UrlBuilderImpl {
        constructor(options) {
            var _a, _b, _c, _d;
            this.apiBaseUrl = parseUrl((_a = options.apiBaseUrl) !== null && _a !== void 0 ? _a : `${(_b = options.cmsBaseUrl) !== null && _b !== void 0 ? _b : ""}${DEFAULT_API_BASE_URL}`);
            this.cmsBaseUrl = parseUrl((_c = options.cmsBaseUrl) !== null && _c !== void 0 ? _c : "");
            this.spaBaseUrl = parseUrl((_d = options.spaBaseUrl) !== null && _d !== void 0 ? _d : DEFAULT_SPA_BASE_URL);
        }
        getApiUrl(link) {
            const {pathname, searchParams} = parseUrl(link);
            if (this.apiBaseUrl.pathname && pathname.startsWith(this.apiBaseUrl.pathname)) {
                return buildUrl({
                    pathname,
                    origin: this.apiBaseUrl.origin,
                    searchParams: mergeSearchParams(this.apiBaseUrl.searchParams, searchParams)
                });
            }
            if (this.spaBaseUrl.pathname && !pathname.startsWith(this.spaBaseUrl.pathname)) {
                throw new Error(`The path "${pathname}" does not start with the base path "${this.spaBaseUrl.pathname}".`);
            }
            const route = pathname.substring(this.spaBaseUrl.pathname.length);
            return buildUrl({
                origin: this.apiBaseUrl.origin,
                pathname: `${this.apiBaseUrl.pathname}${route}`,
                searchParams: mergeSearchParams(searchParams, this.apiBaseUrl.searchParams)
            });
        }
        getSpaUrl(link) {
            const {hash, pathname, searchParams} = parseUrl(link);
            let route = pathname.startsWith(this.cmsBaseUrl.pathname) ? pathname.substring(this.cmsBaseUrl.pathname.length) : pathname;
            if (!route.startsWith("/") && !this.spaBaseUrl.pathname) {
                route = `/${route}`;
            }
            return buildUrl({
                origin: this.spaBaseUrl.origin,
                pathname: `${this.spaBaseUrl.pathname}${route}`,
                searchParams: mergeSearchParams(searchParams, this.spaBaseUrl.searchParams),
                hash: hash || this.spaBaseUrl.hash
            });
        }
    };
    UrlBuilderImpl$1 = __decorate([ inversify.injectable(), __param(0, inversify.inject(UrlBuilderOptionsToken)), __metadata("design:paramtypes", [ Object ]) ], UrlBuilderImpl$1);
    function UrlModule$1() {
        return new inversify.ContainerModule((bind => {
            bind(UrlBuilderService).to(UrlBuilderImpl$1).inSingletonScope();
        }));
    }
    var ApiImpl_1;
    const DEFAULT_API_VERSION_HEADER = "Accept-Version";
    const DEFAULT_AUTHORIZATION_HEADER = "Authorization";
    const DEFAULT_SERVER_ID_HEADER = "Server-Id";
    const ApiOptionsToken = Symbol.for("ApiOptionsToken");
    const ApiService = Symbol.for("ApiService");
    let ApiImpl = ApiImpl_1 = class ApiImpl {
        constructor(urlBuilder, options) {
            this.urlBuilder = urlBuilder;
            this.headers = ApiImpl_1.getHeaders(options);
            this.httpClient = options.httpClient;
        }
        static getHeaders(options) {
            const {remoteAddress: ip} = options.request.connection || {};
            const _a = options.request.headers || {}, headers = __rest(_a, [ "host" ]);
            const {apiVersionHeader = DEFAULT_API_VERSION_HEADER, apiVersion, authorizationHeader = DEFAULT_AUTHORIZATION_HEADER, authorizationToken, serverIdHeader = DEFAULT_SERVER_ID_HEADER, serverId, visitor} = options;
            return _extends(_extends(_extends(_extends(_extends(_extends({}, ip && {
                "x-forwarded-for": ip
            }), apiVersion && {
                [apiVersionHeader]: apiVersion
            }), authorizationToken && {
                [authorizationHeader]: `Bearer ${authorizationToken}`
            }), serverId && {
                [serverIdHeader]: serverId
            }), visitor && {
                [visitor.header]: visitor.id
            }), headers);
        }
        getPage(path) {
            const url = this.urlBuilder.getApiUrl(path);
            return this.send({
                url,
                method: "GET"
            });
        }
        getComponent(url, payload) {
            const data = new URLSearchParams(payload);
            return this.send({
                url,
                data: data.toString(),
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                method: "POST"
            });
        }
        send(config) {
            return __awaiter(this, void 0, void 0, (function*() {
                const response = yield this.httpClient(_extends(_extends({}, config), {
                    headers: _extends(_extends({}, this.headers), config.headers)
                }));
                return response.data;
            }));
        }
    };
    ApiImpl = ApiImpl_1 = __decorate([ inversify.injectable(), __param(0, inversify.inject(UrlBuilderService)), __param(1, inversify.inject(ApiOptionsToken)), __metadata("design:paramtypes", [ Object, Object ]) ], ApiImpl);
    const EventBusService = Symbol("EventBusService");
    function EmitterMixin(Super) {
        return class EmitterMixin extends Super {
            constructor() {
                super(...arguments);
                /**
         * @todo should be private
         * @see https://github.com/Microsoft/TypeScript/issues/17293
         */                this.emitter = new emittery.Typed;
                this.on = this.emitter.on.bind(this.emitter);
                this.off = this.emitter.off.bind(this.emitter);
                /**
         * @todo should be private
         * @see https://github.com/Microsoft/TypeScript/issues/17293
         */                this.emit = this.emitter.emit.bind(this.emitter);
            }
        };
    }
    const RpcClientService = Symbol.for("RpcClientService");
    const RpcServerService = Symbol.for("RpcServerService");
    const TYPE_EVENT = "brxm:event";
    const TYPE_RESPONSE = "brxm:response";
    const TYPE_REQUEST = "brxm:request";
    const STATE_FULFILLED = "fulfilled";
    const STATE_REJECTED = "rejected";
    class Dummy {}
    class Rpc extends(EmitterMixin(Dummy)){
        constructor() {
            super(...arguments);
            this.calls = new Map;
            this.callbacks = new Map;
        }
        generateId() {
            let id;
            do {
                id = `${Math.random()}`.slice(2);
            } while (this.calls.has(id));
            return id;
        }
        call(command, ...payload) {
            return new Promise(((resolve, reject) => {
                const id = this.generateId();
                this.calls.set(id, [ resolve, reject ]);
                this.send({
                    id,
                    command,
                    payload,
                    type: TYPE_REQUEST
                });
            }));
        }
        register(command, callback) {
            this.callbacks.set(command, callback);
        }
        trigger(event, payload) {
            this.send({
                event,
                payload,
                type: TYPE_EVENT
            });
        }
        process(message) {
            switch (message === null || message === void 0 ? void 0 : message.type) {
              case TYPE_EVENT:
                this.processEvent(message);
                break;

              case TYPE_RESPONSE:
                this.processResponse(message);
                break;

              case TYPE_REQUEST:
                this.processRequest(message);
                break;
            }
        }
        processEvent(event) {
            this.emit(event.event, event.payload);
        }
        processResponse(response) {
            if (!this.calls.has(response.id)) {
                return;
            }
            const [resolve, reject] = this.calls.get(response.id);
            this.calls.delete(response.id);
            if (response.state === STATE_REJECTED) {
                return void reject(response.result);
            }
            resolve(response.result);
        }
        processRequest(request) {
            return __awaiter(this, void 0, void 0, (function*() {
                const callback = this.callbacks.get(request.command);
                if (!callback) {
                    return;
                }
                try {
                    return this.send({
                        type: TYPE_RESPONSE,
                        id: request.id,
                        state: STATE_FULFILLED,
                        result: yield callback(...request.payload)
                    });
                } catch (result) {
                    return this.send({
                        result,
                        type: TYPE_RESPONSE,
                        id: request.id,
                        state: STATE_REJECTED
                    });
                }
            }));
        }
    }
    const CmsService = Symbol.for("CmsService");
    const GLOBAL_WINDOW = typeof window === "undefined" ? undefined : window;
    let CmsImpl = class CmsImpl {
        constructor(rpcClient, rpcServer, eventBus) {
            var _a;
            this.rpcClient = rpcClient;
            this.rpcServer = rpcServer;
            this.eventBus = eventBus;
            this.onStateChange = this.onStateChange.bind(this);
            (_a = this.eventBus) === null || _a === void 0 ? void 0 : _a.on("page.ready", this.onPageReady.bind(this));
            this.rpcClient.on("update", this.onUpdate.bind(this));
            this.rpcServer.register("inject", this.inject.bind(this));
        }
        initialize({window = GLOBAL_WINDOW}) {
            var _a, _b, _c, _d;
            if (this.window === window) {
                return;
            }
            this.window = window;
            if (((_b = (_a = this.window) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.readyState) !== "loading") {
                return this.onInitialize();
            }
            (_d = (_c = this.window) === null || _c === void 0 ? void 0 : _c.document) === null || _d === void 0 ? void 0 : _d.addEventListener("readystatechange", this.onStateChange);
        }
        onInitialize() {
            this.rpcServer.trigger("ready", undefined);
        }
        onStateChange() {
            if (this.window.document.readyState === "loading") {
                return;
            }
            this.onInitialize();
            this.window.document.removeEventListener("readystatechange", this.onStateChange);
        }
        onPageReady() {
            this.rpcClient.call("sync");
        }
        onUpdate(event) {
            var _a;
            (_a = this.eventBus) === null || _a === void 0 ? void 0 : _a.emit("cms.update", event);
        }
        inject(resource) {
            var _a;
            if (!((_a = this.window) === null || _a === void 0 ? void 0 : _a.document)) {
                return Promise.reject(new Error("SPA document is not ready."));
            }
            return new Promise(((resolve, reject) => {
                const script = this.window.document.createElement("script");
                script.type = "text/javascript";
                script.src = resource;
                script.addEventListener("load", (() => resolve()));
                script.addEventListener("error", (() => reject(new Error(`Failed to load resource '${resource}'.`))));
                this.window.document.body.appendChild(script);
            }));
        }
    };
    CmsImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(RpcClientService)), __param(1, inversify.inject(RpcServerService)), __param(2, inversify.inject(EventBusService)), __param(2, inversify.optional()), __metadata("design:paramtypes", [ Object, Object, Object ]) ], CmsImpl);
    const GLOBAL_WINDOW$1 = typeof window === "undefined" ? undefined : window;
    let Cms14Impl = class Cms14Impl {
        constructor(eventBus) {
            this.eventBus = eventBus;
            this.postponed = [];
        }
        flush() {
            return __awaiter(this, void 0, void 0, (function*() {
                this.postponed.splice(0).forEach((task => task()));
            }));
        }
        postpone(task) {
            return (...args) => {
                if (this.api) {
                    return task.apply(this, args);
                }
                this.postponed.push(task.bind(this, ...args));
            };
        }
        initialize({window = GLOBAL_WINDOW$1}) {
            var _a;
            if (this.api || !window || window.SPA) {
                return;
            }
            (_a = this.eventBus) === null || _a === void 0 ? void 0 : _a.on("page.ready", this.postpone(this.sync));
            window.SPA = {
                init: this.onInit.bind(this),
                renderComponent: this.onRenderComponent.bind(this)
            };
        }
        onInit(api) {
            this.api = api;
            this.flush();
        }
        onRenderComponent(id, properties) {
            var _a;
            (_a = this.eventBus) === null || _a === void 0 ? void 0 : _a.emit("cms.update", {
                id,
                properties
            });
        }
        sync() {
            this.api.sync();
        }
    };
    Cms14Impl = __decorate([ inversify.injectable(), __param(0, inversify.inject(EventBusService)), __param(0, inversify.optional()), __metadata("design:paramtypes", [ Object ]) ], Cms14Impl);
    const PostMessageService = Symbol.for("PostMessageService");
    const GLOBAL_WINDOW$2 = typeof window === "undefined" ? undefined : window;
    let PostMessage = class PostMessage extends Rpc {
        constructor() {
            super();
            this.onMessage = this.onMessage.bind(this);
        }
        initialize({origin, window = GLOBAL_WINDOW$2}) {
            var _a, _b;
            (_a = this.window) === null || _a === void 0 ? void 0 : _a.removeEventListener("message", this.onMessage, false);
            this.origin = origin;
            this.window = window;
            (_b = this.window) === null || _b === void 0 ? void 0 : _b.addEventListener("message", this.onMessage, false);
        }
        send(message) {
            var _a, _b;
            if (this.origin) {
                (_b = (_a = this.window) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.postMessage(message, this.origin);
            }
        }
        onMessage(event) {
            if (!event.data || !isMatched(event.origin, this.origin === "*" ? "" : this.origin)) {
                return;
            }
            this.process(event.data);
        }
    };
    PostMessage = __decorate([ inversify.injectable(), __metadata("design:paramtypes", []) ], PostMessage);
    function CmsModule() {
        return new inversify.ContainerModule((bind => {
            bind(EventBusService).toDynamicValue((() => new emittery.Typed)).inSingletonScope().when((() => typeof window !== "undefined"));
            bind(PostMessageService).to(PostMessage).inSingletonScope();
            bind(RpcClientService).toService(PostMessageService);
            bind(RpcServerService).toService(PostMessageService);
            bind(CmsService).to(CmsImpl).inSingletonScope().whenTargetIsDefault();
            bind(CmsService).to(Cms14Impl).inSingletonScope().whenTargetNamed("cms14");
        }));
    }
    /**
   * Link to a page outside the current application.
   */    const TYPE_LINK_EXTERNAL = "external";
    /**
   * Link to a page inside the current application.
   */    const TYPE_LINK_INTERNAL = "internal";
    /**
   * Link to a CMS resource.
   */    const TYPE_LINK_RESOURCE = "resource";
    /**
   * Unresolved link.
   */    const TYPE_LINK_UNKNOWN = "unknown";
    /**
   * Checks whether a value is a link.
   * @param value The value to check.
   */    function isLink(value) {
        return !!value && (Object.prototype.hasOwnProperty.call(value, "href") || Object.prototype.hasOwnProperty.call(value, "type") && [ TYPE_LINK_EXTERNAL, TYPE_LINK_INTERNAL, TYPE_LINK_RESOURCE, TYPE_LINK_UNKNOWN ].includes(value.type));
    }
    class SimpleFactory {
        constructor() {
            this.mapping = new Map;
        }
        /**
     * Registers a builder for the specified type.
     * @param type The entity type.
     * @param builder The entity builder.
     */        register(type, builder) {
            this.mapping.set(type, builder);
            return this;
        }
    }
    let LinkFactory = class LinkFactory extends SimpleFactory {
        create(link) {
            if (isLink(link)) {
                return this.createLink(link);
            }
            return this.createPath(link);
        }
        createLink(link) {
            if (!link.type || typeof link.href === "undefined" || !this.mapping.has(link.type)) {
                return link.href;
            }
            const builder = this.mapping.get(link.type);
            return builder(link.href);
        }
        createPath(path) {
            return this.createLink({
                href: path,
                type: TYPE_LINK_INTERNAL
            });
        }
    };
    LinkFactory = __decorate([ inversify.injectable() ], LinkFactory);
    const MetaCollectionFactory = Symbol.for("MetaCollectionFactory");
    const ComponentChildrenToken = Symbol.for("ComponentChildrenToken");
    const ComponentModelToken = Symbol.for("ComponentModelToken");
    /**
   * Generic component type.
   */    const TYPE_COMPONENT = "component";
    /**
   * Container item type.
   */    const TYPE_COMPONENT_CONTAINER_ITEM = "container-item";
    /**
   * Container type.
   */    const TYPE_COMPONENT_CONTAINER = "container";
    let ComponentImpl = class ComponentImpl {
        constructor(model, children, linkFactory, metaFactory) {
            this.model = model;
            this.children = children;
            this.linkFactory = linkFactory;
            this.meta = metaFactory(this.model.meta);
        }
        getId() {
            return this.model.id;
        }
        getMeta() {
            return this.meta;
        }
        getModels() {
            return this.model.models || {};
        }
        getUrl() {
            return this.linkFactory.create(this.model.links.self);
        }
        getName() {
            return this.model.name || "";
        }
        getParameters() {
            var _a;
            return (_a = this.model.meta.params) !== null && _a !== void 0 ? _a : {};
        }
        getChildren() {
            return this.children;
        }
        getComponent(...componentNames) {
            let component = this;
            while (componentNames.length && component) {
                const name = componentNames.shift();
                component = component.getChildren().find((component => component.getName() === name));
            }
            return component;
        }
        getComponentById(id) {
            const queue = [ this ];
            while (queue.length) {
                const component = queue.shift();
                if (component.getId() === id) {
                    return component;
                }
                queue.push(...component.getChildren());
            }
        }
    };
    ComponentImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(ComponentModelToken)), __param(1, inversify.inject(ComponentChildrenToken)), __param(2, inversify.inject(LinkFactory)), __param(3, inversify.inject(MetaCollectionFactory)), __metadata("design:paramtypes", [ Object, Array, LinkFactory, Function ]) ], ComponentImpl);
    /**
   * Checks whether a value is a page component.
   * @param value The value to check.
   */    function isComponent(value) {
        return value instanceof ComponentImpl;
    }
    /**
   * Generic component type.
   */    const TYPE_COMPONENT$1 = "COMPONENT";
    /**
   * Container item type.
   */    const TYPE_COMPONENT_CONTAINER_ITEM$1 = "CONTAINER_ITEM_COMPONENT";
    /**
   * Container type.
   */    const TYPE_COMPONENT_CONTAINER$1 = "CONTAINER_COMPONENT";
    let ComponentImpl$1 = class ComponentImpl {
        constructor(model, children, metaFactory, urlBuilder) {
            this.model = model;
            this.children = children;
            this.urlBuilder = urlBuilder;
            this.meta = metaFactory(this.model._meta);
        }
        getId() {
            return this.model.id;
        }
        getMeta() {
            return this.meta;
        }
        getModels() {
            return this.model.models || {};
        }
        getUrl() {
            return this.urlBuilder.getApiUrl(this.model._links.componentRendering.href);
        }
        getName() {
            return this.model.name || "";
        }
        getParameters() {
            var _a;
            return (_a = this.model._meta.params) !== null && _a !== void 0 ? _a : {};
        }
        getChildren() {
            return this.children;
        }
        getComponent(...componentNames) {
            let component = this;
            while (componentNames.length && component) {
                const name = componentNames.shift();
                component = component.getChildren().find((component => component.getName() === name));
            }
            return component;
        }
        getComponentById(id) {
            const queue = [ this ];
            while (queue.length) {
                const component = queue.shift();
                if (component.getId() === id) {
                    return component;
                }
                queue.push(...component.getChildren());
            }
        }
    };
    ComponentImpl$1 = __decorate([ inversify.injectable(), __param(0, inversify.inject(ComponentModelToken)), __param(1, inversify.inject(ComponentChildrenToken)), __param(2, inversify.inject(MetaCollectionFactory)), __param(3, inversify.inject(UrlBuilderService)), __metadata("design:paramtypes", [ Object, Array, Function, Object ]) ], ComponentImpl$1);
    /**
   * Checks whether a value is a page component.
   * @param value The value to check.
   */    function isComponent$1(value) {
        return value instanceof ComponentImpl$1;
    }
    /**
   * A blocked container with blocked items.
   */    const TYPE_CONTAINER_BOX = "hst.vbox";
    /**
   * An unordered list container.
   */    const TYPE_CONTAINER_UNORDERED_LIST = "hst.unorderedlist";
    /**
   * An ordered list container.
   */    const TYPE_CONTAINER_ORDERED_LIST = "hst.orderedlist";
    /**
   * A blocked container with inline items.
   */    const TYPE_CONTAINER_INLINE = "hst.span";
    /**
   * A container without surrounding markup.
   */    const TYPE_CONTAINER_NO_MARKUP = "hst.nomarkup";
    let ContainerImpl = class ContainerImpl extends ComponentImpl {
        getChildren() {
            return this.children;
        }
        getType() {
            var _a;
            return (_a = this.model.xtype) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        }
    };
    ContainerImpl = __decorate([ inversify.injectable() ], ContainerImpl);
    /**
   * Checks whether a value is a page container.
   * @param value The value to check.
   */    function isContainer(value) {
        return value instanceof ContainerImpl;
    }
    let ContainerImpl$1 = class ContainerImpl extends ComponentImpl$1 {
        getChildren() {
            return this.children;
        }
        getType() {
            var _a;
            return (_a = this.model.xtype) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        }
    };
    ContainerImpl$1 = __decorate([ inversify.injectable() ], ContainerImpl$1);
    /**
   * Checks whether a value is a page container.
   * @param value The value to check.
   */    function isContainer$1(value) {
        return value instanceof ContainerImpl$1;
    }
    const EventBusService$1 = Symbol("EventBusService");
    /**
   * Checks whether a value is a reference.
   * @param value The value to check.
   */    function isReference(value) {
        return !!(value === null || value === void 0 ? void 0 : value.$ref);
    }
    function resolve(object, reference) {
        return reference.$ref.split("/").reduce(((value, key) => key ? value === null || value === void 0 ? void 0 : value[key] : object), object);
    }
    const PARAMETER_HIDDEN = "com.onehippo.cms7.targeting.TargetingParameterUtil.hide";
    let ContainerItemImpl = class ContainerItemImpl extends(EmitterMixin(ComponentImpl)){
        constructor(model, linkFactory, metaFactory, eventBus) {
            super(model, [], linkFactory, metaFactory);
            this.model = model;
            this.metaFactory = metaFactory;
            eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
        }
        onPageUpdate(event) {
            const page = event.page;
            const model = resolve(page, page.root);
            if ((model === null || model === void 0 ? void 0 : model.id) !== this.getId()) {
                return;
            }
            this.model = model;
            this.meta = this.metaFactory(model.meta);
            this.emit("update", {});
        }
        getLabel() {
            return this.model.label;
        }
        getType() {
            var _a;
            return (_a = this.model.ctype) !== null && _a !== void 0 ? _a : this.model.label;
        }
        isHidden() {
            var _a;
            return ((_a = this.model.meta.params) === null || _a === void 0 ? void 0 : _a[PARAMETER_HIDDEN]) === "on";
        }
        getParameters() {
            var _a;
            return (_a = this.model.meta.paramsInfo) !== null && _a !== void 0 ? _a : {};
        }
    };
    ContainerItemImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(ComponentModelToken)), __param(1, inversify.inject(LinkFactory)), __param(2, inversify.inject(MetaCollectionFactory)), __param(3, inversify.inject(EventBusService$1)), __param(3, inversify.optional()), __metadata("design:paramtypes", [ Object, LinkFactory, Function, Object ]) ], ContainerItemImpl);
    /**
   * Checks whether a value is a page container item.
   * @param value The value to check.
   */    function isContainerItem(value) {
        return value instanceof ContainerItemImpl;
    }
    const PARAMETER_HIDDEN$1 = "com.onehippo.cms7.targeting.TargetingParameterUtil.hide";
    let ContainerItemImpl$1 = class ContainerItemImpl extends(EmitterMixin(ComponentImpl$1)){
        constructor(model, metaFactory, urlBuilder, eventBus) {
            super(model, [], metaFactory, urlBuilder);
            this.model = model;
            this.metaFactory = metaFactory;
            eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
        }
        onPageUpdate(event) {
            const {page: model} = event.page;
            if (model.id !== this.getId()) {
                return;
            }
            this.model = model;
            this.meta = this.metaFactory(model._meta);
            this.emit("update", {});
        }
        getLabel() {
            return this.model.label;
        }
        getType() {
            var _a;
            return (_a = this.model.ctype) !== null && _a !== void 0 ? _a : this.model.label;
        }
        isHidden() {
            var _a;
            return ((_a = this.model._meta.params) === null || _a === void 0 ? void 0 : _a[PARAMETER_HIDDEN$1]) === "on";
        }
        getParameters() {
            var _a;
            return (_a = this.model._meta.paramsInfo) !== null && _a !== void 0 ? _a : {};
        }
    };
    ContainerItemImpl$1 = __decorate([ inversify.injectable(), __param(0, inversify.inject(ComponentModelToken)), __param(1, inversify.inject(MetaCollectionFactory)), __param(2, inversify.inject(UrlBuilderService)), __param(3, inversify.inject(EventBusService$1)), __param(3, inversify.optional()), __metadata("design:paramtypes", [ Object, Function, Object, Object ]) ], ContainerItemImpl$1);
    /**
   * Checks whether a value is a page container item.
   * @param value The value to check.
   */    function isContainerItem$1(value) {
        return value instanceof ContainerItemImpl$1;
    }
    /**
   * The factory to produce meta-data collection from the page model meta-data.
   */    let MetaFactory = class MetaFactory extends SimpleFactory {
        create(meta, position) {
            const builder = this.mapping.get(meta.type);
            if (!builder) {
                throw new Error(`Unsupported meta type: '${meta.type}'.`);
            }
            return builder(meta, position);
        }
    };
    MetaFactory = __decorate([ inversify.injectable() ], MetaFactory);
    const TYPE_META_COMMENT = "comment";
    /**
   * Meta-data following before a page component.
   */    const META_POSITION_BEGIN = "begin";
    /**
   * Meta-data following after a page component.
   */    const META_POSITION_END = "end";
    class MetaImpl {
        constructor(model, position) {
            this.model = model;
            this.position = position;
        }
        getData() {
            return this.model.data;
        }
        getPosition() {
            return this.position;
        }
    }
    /**
   * Checks whether a value is a meta-data object.
   * @param value The value to check.
   */    function isMeta(value) {
        return value instanceof MetaImpl;
    }
    const HTML_COMMENT = /^<!--(.*)-->$/;
    /**
   * Meta information stored in HST-comments.
   */    class MetaCommentImpl extends MetaImpl {
        getData() {
            const data = super.getData();
            const [, payload = data] = data.match(HTML_COMMENT) || [];
            return payload;
        }
    }
    /**
   * Checks whether a value is a meta-data comment.
   * @param value The value to check.
   */    function isMetaComment(value) {
        return value instanceof MetaCommentImpl;
    }
    var MetaCollectionImpl_1;
    const MetaCollectionModelToken = Symbol.for("MetaCollectionModelToken");
    let MetaCollectionImpl = MetaCollectionImpl_1 = class MetaCollectionImpl extends Array {
        constructor(model, metaFactory) {
            super(...(model.beginNodeSpan || []).map((model => metaFactory.create(model, META_POSITION_BEGIN))), ...(model.endNodeSpan || []).map((model => metaFactory.create(model, META_POSITION_END))));
            this.comments = [];
            const prototype = Object.create(MetaCollectionImpl_1.prototype);
            prototype.constructor = Array.prototype.constructor;
            Object.setPrototypeOf(this, prototype);
            Object.freeze(this);
        }
        clear(comments = [ ...this.comments ]) {
            comments.forEach((comment => {
                comment.remove();
                const index = this.comments.indexOf(comment);
                if (index > -1) {
                    this.comments.splice(index, 1);
                }
            }));
        }
        render(head, tail) {
            var _a;
            const document = (_a = head.ownerDocument) !== null && _a !== void 0 ? _a : tail.ownerDocument;
            const comments = document ? [ ...this.filter(isMetaComment).filter((meta => meta.getPosition() === META_POSITION_BEGIN)).map((meta => document.createComment(meta.getData()))).map((comment => {
                var _a;
                (_a = head.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(comment, head);
                return comment;
            })), ...this.filter(isMetaComment).filter((meta => meta.getPosition() === META_POSITION_END)).reverse().map((meta => document.createComment(meta.getData()))).map((comment => {
                var _a, _b;
                if (tail.nextSibling) {
                    (_a = tail.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(comment, tail.nextSibling);
                } else {
                    (_b = tail.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(comment);
                }
                return comment;
            })) ] : [];
            this.comments.push(...comments);
            return this.clear.bind(this, comments);
        }
    };
    MetaCollectionImpl = MetaCollectionImpl_1 = __decorate([ inversify.injectable(), __param(0, inversify.inject(MetaCollectionModelToken)), __param(1, inversify.inject(MetaFactory)), __metadata("design:paramtypes", [ Object, MetaFactory ]) ], MetaCollectionImpl);
    /**
   * Checks whether a value is a meta-data collection.
   * @param value The value to check.
   */    function isMetaCollection(value) {
        return value instanceof MetaCollectionImpl;
    }
    let ButtonFactory = class ButtonFactory extends SimpleFactory {
        constructor(metaCollectionFactory) {
            super();
            this.metaCollectionFactory = metaCollectionFactory;
        }
        create(type, ...params) {
            if (!this.mapping.has(type)) {
                throw new Error(`Unsupported button type: '${type}'.`);
            }
            const meta = this.mapping.get(type)(...params);
            return isMetaCollection(meta) ? meta : this.metaCollectionFactory(meta);
        }
    };
    ButtonFactory = __decorate([ inversify.injectable(), __param(0, inversify.inject(MetaCollectionFactory)), __metadata("design:paramtypes", [ Function ]) ], ButtonFactory);
    /**
   * A component factory producing components based on a type.
   */    let ComponentFactory = class ComponentFactory extends SimpleFactory {
        /**
     * Produces a component based on the page model.
     * @param page The page model.
     */
        create(page) {
            var _a, _b;
            const heap = [ page.root ];
            const pool = new Map;
            for (let i = 0; i < heap.length; i++) {
                heap.push(...(_b = (_a = resolve(page, heap[i])) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : []);
            }
            return heap.reverse().reduce(((previous, reference) => {
                var _a, _b;
                const model = resolve(page, reference);
                const children = (_b = (_a = model === null || model === void 0 ? void 0 : model.children) === null || _a === void 0 ? void 0 : _a.map((child => pool.get(resolve(page, child))))) !== null && _b !== void 0 ? _b : [];
                const component = this.buildComponent(model, children);
                pool.set(model, component);
                return component;
            }), undefined);
        }
        buildComponent(model, children) {
            const builder = this.mapping.get(model.type);
            if (!builder) {
                throw new Error(`Unsupported component type: '${model.type}'.`);
            }
            return builder(model, children);
        }
    };
    ComponentFactory = __decorate([ inversify.injectable() ], ComponentFactory);
    let ContentFactory = class ContentFactory extends SimpleFactory {
        create(model) {
            if (!this.mapping.has(model.type)) {
                return model;
            }
            return this.mapping.get(model.type)(model);
        }
    };
    ContentFactory = __decorate([ inversify.injectable() ], ContentFactory);
    const DomParserService = Symbol.for("DomParserService");
    const LinkRewriterService = Symbol.for("LinkRewriterService");
    const XmlSerializerService = Symbol.for("XmlSerializerService");
    const BODY_CONTENTS = /^<body.*?>(.*)<\/body>$/;
    let LinkRewriterImpl = class LinkRewriterImpl {
        constructor(linkFactory, domParser, xmlSerializer) {
            this.linkFactory = linkFactory;
            this.domParser = domParser;
            this.xmlSerializer = xmlSerializer;
        }
        rewrite(content, type = "text/html") {
            const document = this.domParser.parseFromString(`<body>${content}</body>`, type);
            this.rewriteAnchors(document);
            this.rewriteImages(document);
            const body = this.xmlSerializer.serializeToString(document);
            return body.replace(BODY_CONTENTS, "$1");
        }
        rewriteAnchors(document) {
            Array.from(document.getElementsByTagName("a")).filter((element => element.hasAttribute("href") && element.hasAttribute("data-type"))).forEach((element => {
                var _a;
                const url = this.linkFactory.create({
                    href: (_a = element.getAttribute("href")) !== null && _a !== void 0 ? _a : undefined,
                    type: element.getAttribute("data-type")
                });
                if (url) {
                    element.setAttribute("href", url);
                }
            }));
        }
        rewriteImages(document) {
            Array.from(document.getElementsByTagName("img")).filter((element => element.hasAttribute("src"))).forEach((element => {
                var _a;
                const url = this.linkFactory.create({
                    href: (_a = element.getAttribute("src")) !== null && _a !== void 0 ? _a : undefined,
                    type: TYPE_LINK_RESOURCE
                });
                if (url) {
                    element.setAttribute("src", url);
                }
            }));
        }
    };
    LinkRewriterImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(LinkFactory)), __param(1, inversify.inject(DomParserService)), __param(2, inversify.inject(XmlSerializerService)), __metadata("design:paramtypes", [ LinkFactory, xmldom.DOMParser, xmldom.XMLSerializer ]) ], LinkRewriterImpl);
    const PageModelToken = Symbol.for("PageModelToken");
    let PageImpl = class PageImpl {
        constructor(model, buttonFactory, componentFactory, contentFactory, linkFactory, linkRewriter, metaFactory, cmsEventBus, eventBus) {
            this.model = model;
            this.buttonFactory = buttonFactory;
            this.contentFactory = contentFactory;
            this.linkFactory = linkFactory;
            this.linkRewriter = linkRewriter;
            this.metaFactory = metaFactory;
            this.cmsEventBus = cmsEventBus;
            this.content = new WeakMap;
            eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
            this.root = componentFactory.create(model);
        }
        onPageUpdate(event) {
            _extends(this.model.page, event.page.page);
        }
        getButton(type, ...params) {
            return this.buttonFactory.create(type, ...params);
        }
        getChannelParameters() {
            return this.model.channel.info.props;
        }
        getComponent(...componentNames) {
            var _a;
            return (_a = this.root) === null || _a === void 0 ? void 0 : _a.getComponent(...componentNames);
        }
        getContent(reference) {
            const model = resolve(this.model, isReference(reference) ? reference : {
                $ref: `/page/${reference}`
            });
            if (!model) {
                return undefined;
            }
            if (!this.content.has(model)) {
                this.content.set(model, this.contentFactory.create(model));
            }
            return this.content.get(model);
        }
        getDocument() {
            return this.model.document && this.getContent(this.model.document);
        }
        getMeta(meta) {
            return this.metaFactory(meta);
        }
        getTitle() {
            var _a, _b;
            return (_b = (_a = resolve(this.model, this.model.root)) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.pageTitle;
        }
        getUrl(link) {
            var _a, _b, _c;
            if (typeof link === "undefined" || isLink(link) || isAbsoluteUrl(link)) {
                return this.linkFactory.create((_b = (_a = link) !== null && _a !== void 0 ? _a : this.model.links.site) !== null && _b !== void 0 ? _b : "");
            }
            return resolveUrl(link, (_c = this.linkFactory.create(this.model.links.site)) !== null && _c !== void 0 ? _c : "");
        }
        getVersion() {
            return this.model.meta.version;
        }
        getVisitor() {
            return this.model.meta.visitor;
        }
        getVisit() {
            return this.model.meta.visit;
        }
        isPreview() {
            return !!this.model.meta.preview;
        }
        rewriteLinks(content, type = "text/html") {
            return this.linkRewriter.rewrite(content, type);
        }
        sync() {
            var _a;
            (_a = this.cmsEventBus) === null || _a === void 0 ? void 0 : _a.emit("page.ready", {});
        }
        toJSON() {
            return this.model;
        }
    };
    PageImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(PageModelToken)), __param(1, inversify.inject(ButtonFactory)), __param(2, inversify.inject(ComponentFactory)), __param(3, inversify.inject(ContentFactory)), __param(4, inversify.inject(LinkFactory)), __param(5, inversify.inject(LinkRewriterService)), __param(6, inversify.inject(MetaCollectionFactory)), __param(7, inversify.inject(EventBusService)), __param(7, inversify.optional()), __param(8, inversify.inject(EventBusService$1)), __param(8, inversify.optional()), __metadata("design:paramtypes", [ Object, ButtonFactory, ComponentFactory, ContentFactory, LinkFactory, Object, Function, Object, Object ]) ], PageImpl);
    /**
   * Checks whether a value is a page.
   * @param value The value to check.
   */    function isPage(value) {
        return value instanceof PageImpl;
    }
    /**
   * A component factory producing components based on a type.
   */    let ComponentFactory$1 = class ComponentFactory extends SimpleFactory {
        /**
     * Produces a component based on the model.
     * @param model The component model.
     */
        create(model) {
            var _a, _b;
            let component;
            const queue = [ {
                model
            } ];
            while (queue.length) {
                const head = queue.shift();
                if (!head.children && ((_a = head.model.components) === null || _a === void 0 ? void 0 : _a.length)) {
                    head.children = [];
                    queue.unshift(...head.model.components.map((model => ({
                        model,
                        siblings: head.children
                    }))), head);
                    continue;
                }
                component = this.buildComponent(head.model, (_b = head.children) !== null && _b !== void 0 ? _b : []);
                if (head.siblings) {
                    head.siblings.push(component);
                }
            }
            return component;
        }
        buildComponent(model, children) {
            const builder = this.mapping.get(model.type);
            if (!builder) {
                throw new Error(`Unsupported component type: '${model.type}'.`);
            }
            return builder(model, children);
        }
    };
    ComponentFactory$1 = __decorate([ inversify.injectable() ], ComponentFactory$1);
    const ContentFactory$1 = Symbol.for("ContentFactory");
    var PageImpl_1;
    let PageImpl$1 = PageImpl_1 = class PageImpl {
        constructor(model, buttonFactory, componentFactory, contentFactory, linkFactory, linkRewriter, metaFactory, cmsEventBus, eventBus) {
            this.model = model;
            this.buttonFactory = buttonFactory;
            this.contentFactory = contentFactory;
            this.linkFactory = linkFactory;
            this.linkRewriter = linkRewriter;
            this.metaFactory = metaFactory;
            this.cmsEventBus = cmsEventBus;
            eventBus === null || eventBus === void 0 ? void 0 : eventBus.on("page.update", this.onPageUpdate.bind(this));
            this.root = componentFactory.create(model.page);
            this.content = new Map(Object.entries(model.content || {}).map((([alias, model]) => [ alias, this.contentFactory(model) ])));
        }
        onPageUpdate(event) {
            Object.entries(event.page.content || {}).forEach((([alias, model]) => this.content.set(alias, this.contentFactory(model))));
        }
        static getContentReference(reference) {
            return reference.$ref.split("/", 3)[2] || "";
        }
        getButton(type, ...params) {
            return this.buttonFactory.create(type, ...params);
        }
        getChannelParameters() {
            var _a, _b;
            return (_b = (_a = this.model.channel) === null || _a === void 0 ? void 0 : _a.info.props) !== null && _b !== void 0 ? _b : {};
        }
        getComponent(...componentNames) {
            return this.root.getComponent(...componentNames);
        }
        getContent(reference) {
            const contentReference = isReference(reference) ? PageImpl_1.getContentReference(reference) : reference;
            return this.content.get(contentReference);
        }
        getDocument() {
            throw new Error("The page document is not supported by this version of the Page Model API.");
        }
        getMeta(meta) {
            return this.metaFactory(meta);
        }
        getTitle() {
            return this.model.page._meta.pageTitle;
        }
        getUrl(link) {
            var _a;
            return this.linkFactory.create((_a = link) !== null && _a !== void 0 ? _a : _extends(_extends({}, this.model._links.site), {
                type: TYPE_LINK_INTERNAL
            }));
        }
        getVersion() {
            return this.model._meta.version;
        }
        getVisitor() {
            return this.model._meta.visitor;
        }
        getVisit() {
            return this.model._meta.visit;
        }
        isPreview() {
            return !!this.model._meta.preview;
        }
        rewriteLinks(content, type = "text/html") {
            return this.linkRewriter.rewrite(content, type);
        }
        sync() {
            var _a;
            (_a = this.cmsEventBus) === null || _a === void 0 ? void 0 : _a.emit("page.ready", {});
        }
        toJSON() {
            return this.model;
        }
    };
    PageImpl$1 = PageImpl_1 = __decorate([ inversify.injectable(), __param(0, inversify.inject(PageModelToken)), __param(1, inversify.inject(ButtonFactory)), __param(2, inversify.inject(ComponentFactory$1)), __param(3, inversify.inject(ContentFactory$1)), __param(4, inversify.inject(LinkFactory)), __param(5, inversify.inject(LinkRewriterService)), __param(6, inversify.inject(MetaCollectionFactory)), __param(7, inversify.inject(EventBusService)), __param(7, inversify.optional()), __param(8, inversify.inject(EventBusService$1)), __param(8, inversify.optional()), __metadata("design:paramtypes", [ Object, ButtonFactory, ComponentFactory$1, Function, LinkFactory, Object, Function, Object, Object ]) ], PageImpl$1);
    /**
   * Checks whether a value is a page.
   * @param value The value to check.
   */    function isPage$1(value) {
        return value instanceof PageImpl$1;
    }
    const ContentModelToken = Symbol.for("ContentModelToken");
    let ContentImpl = class ContentImpl {
        constructor(model, linkFactory, metaFactory) {
            var _a;
            this.model = model;
            this.linkFactory = linkFactory;
            this.meta = metaFactory((_a = this.model._meta) !== null && _a !== void 0 ? _a : {});
        }
        getId() {
            return this.model.id;
        }
        getLocale() {
            return this.model.localeString;
        }
        getMeta() {
            return this.meta;
        }
        getName() {
            return this.model.name;
        }
        getData() {
            return this.model;
        }
        getUrl() {
            return this.linkFactory.create(this.model._links.site);
        }
    };
    ContentImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(ContentModelToken)), __param(1, inversify.inject(LinkFactory)), __param(2, inversify.inject(MetaCollectionFactory)), __metadata("design:paramtypes", [ Object, LinkFactory, Function ]) ], ContentImpl);
    /**
   * Checks whether a value is a content.
   * @param value The value to check.
   */    function isContent(value) {
        return value instanceof ContentImpl;
    }
    const DocumentModelToken = Symbol.for("DocumentModelToken");
    const TYPE_DOCUMENT = "document";
    let DocumentImpl = class DocumentImpl {
        constructor(model, linkFactory, metaFactory) {
            var _a;
            this.model = model;
            this.linkFactory = linkFactory;
            this.meta = metaFactory((_a = this.model.meta) !== null && _a !== void 0 ? _a : {});
        }
        getId() {
            return this.model.data.id;
        }
        getLocale() {
            return this.model.data.localeString;
        }
        getMeta() {
            return this.meta;
        }
        getName() {
            return this.model.data.name;
        }
        getData() {
            return this.model.data;
        }
        getUrl() {
            return this.linkFactory.create(this.model.links.site);
        }
    };
    DocumentImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(DocumentModelToken)), __param(1, inversify.inject(LinkFactory)), __param(2, inversify.inject(MetaCollectionFactory)), __metadata("design:paramtypes", [ Object, LinkFactory, Function ]) ], DocumentImpl);
    /**
   * Checks whether a value is a document.
   * @param value The value to check.
   */    function isDocument(value) {
        return value instanceof DocumentImpl;
    }
    const ImageFactory = Symbol.for("ImageFactory");
    const ImageModelToken = Symbol.for("ImageModelToken");
    let ImageImpl = class ImageImpl {
        constructor(model, linkFactory) {
            this.model = model;
            this.linkFactory = linkFactory;
        }
        getDisplayName() {
            return this.model.displayName;
        }
        getFileName() {
            var _a;
            return (_a = this.model.fileName) !== null && _a !== void 0 ? _a : undefined;
        }
        getHeight() {
            return this.model.height;
        }
        getMimeType() {
            return this.model.mimeType;
        }
        getName() {
            return this.model.name;
        }
        getSize() {
            return this.model.size;
        }
        getUrl() {
            return this.model.links.site && this.linkFactory.create(this.model.links.site);
        }
        getWidth() {
            return this.model.width;
        }
    };
    ImageImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(ImageModelToken)), __param(1, inversify.inject(LinkFactory)), __metadata("design:paramtypes", [ Object, LinkFactory ]) ], ImageImpl);
    const ImageSetModelToken = Symbol.for("ImageSetModelToken");
    const TYPE_IMAGE_SET = "imageset";
    let ImageSetImpl = class ImageSetImpl {
        constructor(model, imageFactory) {
            this.model = model;
            this.original = model.data.original ? imageFactory(model.data.original) : undefined;
            this.thumbnail = model.data.thumbnail ? imageFactory(model.data.thumbnail) : undefined;
        }
        getDescription() {
            var _a;
            return (_a = this.model.data.description) !== null && _a !== void 0 ? _a : undefined;
        }
        getDisplayName() {
            return this.model.data.displayName;
        }
        getFileName() {
            var _a;
            return (_a = this.model.data.fileName) !== null && _a !== void 0 ? _a : undefined;
        }
        getId() {
            return this.model.data.id;
        }
        getLocale() {
            var _a;
            return (_a = this.model.data.localeString) !== null && _a !== void 0 ? _a : undefined;
        }
        getName() {
            return this.model.data.name;
        }
        getOriginal() {
            return this.original;
        }
        getThumbnail() {
            return this.thumbnail;
        }
    };
    ImageSetImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(ImageSetModelToken)), __param(1, inversify.inject(ImageFactory)), __metadata("design:paramtypes", [ Object, Function ]) ], ImageSetImpl);
    /**
   * Checks whether a value is an image set.
   * @param value The value to check.
   */    function isImageSet(value) {
        return value instanceof ImageSetImpl;
    }
    /**
   * A manage content button.
   */    const TYPE_MANAGE_CONTENT_BUTTON = "MANAGE_CONTENT_LINK";
    function createManageContentButton(params) {
        var _a;
        const meta = (_a = params.content) === null || _a === void 0 ? void 0 : _a.getMeta();
        const entries = [ [ "defaultPath", params.path ], [ "documentTemplateQuery", params.documentTemplateQuery ], [ "folderTemplateQuery", params.folderTemplateQuery ], [ "rootPath", params.root ], [ "parameterName", params.parameter ], [ "parameterValueIsRelativePath", params.relative ? "true" : undefined ] ].filter((([, value]) => !!value));
        if (!entries.length) {
            return meta !== null && meta !== void 0 ? meta : {};
        }
        const model = Object.fromEntries(entries);
        if (!meta) {
            return {
                beginNodeSpan: [ {
                    type: TYPE_META_COMMENT,
                    data: JSON.stringify(_extends({
                        "HST-Type": TYPE_MANAGE_CONTENT_BUTTON
                    }, model))
                } ]
            };
        }
        const merge = item => ({
            type: TYPE_META_COMMENT,
            data: JSON.stringify(_extends(JSON.parse(item.getData()), model))
        });
        return {
            beginNodeSpan: meta.filter((item => item.getPosition() === META_POSITION_BEGIN)).map(merge),
            endNodeSpan: meta.filter((item => item.getPosition() === META_POSITION_END)).map(merge)
        };
    }
    const MenuItemFactory = Symbol.for("MenuItemFactory");
    const MenuItemModelToken = Symbol.for("MenuItemModelToken");
    let MenuItemImpl = class MenuItemImpl {
        constructor(model, linkFactory, menuItemFactory) {
            this.model = model;
            this.linkFactory = linkFactory;
            this.children = model.childMenuItems.map(menuItemFactory);
        }
        getChildren() {
            return this.children;
        }
        getDepth() {
            return this.model.depth;
        }
        getLink() {
            return this.model.links.site;
        }
        getName() {
            return this.model.name;
        }
        getParameters() {
            return this.model.parameters;
        }
        getUrl() {
            return this.model.links.site && this.linkFactory.create(this.model.links.site);
        }
        isExpanded() {
            return this.model.expanded;
        }
        isRepositoryBased() {
            return this.model.repositoryBased;
        }
        isSelected() {
            return this.model.selected;
        }
    };
    MenuItemImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(MenuItemModelToken)), __param(1, inversify.inject(LinkFactory)), __param(2, inversify.inject(MenuItemFactory)), __metadata("design:paramtypes", [ Object, LinkFactory, Function ]) ], MenuItemImpl);
    const MenuModelToken = Symbol.for("MenuModelToken");
    /**
   * A manage menu button.
   */    const TYPE_MANAGE_MENU_BUTTON = "EDIT_MENU_LINK";
    const TYPE_MENU = "menu";
    let MenuImpl = class MenuImpl {
        constructor(model, metaFactory, menuItemFactory) {
            this.model = model;
            this.items = model.data.siteMenuItems.map(menuItemFactory);
            this.meta = metaFactory(model.meta);
            this.selected = model.data.selectSiteMenuItem ? menuItemFactory(model.data.selectSiteMenuItem) : undefined;
        }
        getItems() {
            return this.items;
        }
        getMeta() {
            return this.meta;
        }
        getName() {
            return this.model.data.name;
        }
        getSelected() {
            return this.selected;
        }
    };
    MenuImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(MenuModelToken)), __param(1, inversify.inject(MetaCollectionFactory)), __param(2, inversify.inject(MenuItemFactory)), __metadata("design:paramtypes", [ Object, Function, Function ]) ], MenuImpl);
    /**
   * Checks whether a value is a menu.
   * @param value The value to check.
   */    function isMenu(value) {
        return value instanceof MenuImpl;
    }
    const PageFactory = Symbol.for("PageFactory");
    const PaginationItemFactory = Symbol.for("PaginationItemFactory");
    const PaginationItemModelToken = Symbol.for("PaginationItemModelToken");
    let PaginationItemImpl = class PaginationItemImpl {
        constructor(model, linkFactory) {
            this.model = model;
            this.linkFactory = linkFactory;
        }
        getNumber() {
            return this.model.number;
        }
        getUrl() {
            return this.linkFactory.create(this.model.links.site);
        }
    };
    PaginationItemImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(PaginationItemModelToken)), __param(1, inversify.inject(LinkFactory)), __metadata("design:paramtypes", [ Object, LinkFactory ]) ], PaginationItemImpl);
    const PaginationModelToken = Symbol.for("PaginationModelToken");
    const TYPE_PAGINATION = "pagination";
    let PaginationImpl = class PaginationImpl {
        constructor(model, paginationItemFactory) {
            this.model = model;
            this.current = paginationItemFactory(model.current);
            this.first = paginationItemFactory(model.first);
            this.last = paginationItemFactory(model.last);
            this.next = model.next ? paginationItemFactory(model.next) : undefined;
            this.previous = model.previous ? paginationItemFactory(model.previous) : undefined;
            this.pages = model.pages.map(paginationItemFactory);
        }
        getCurrent() {
            return this.current;
        }
        getFirst() {
            return this.first;
        }
        getItems() {
            return this.model.items;
        }
        getLast() {
            return this.last;
        }
        getNext() {
            return this.next;
        }
        getOffset() {
            return this.model.offset;
        }
        getPages() {
            return this.pages;
        }
        getPrevious() {
            return this.previous;
        }
        getSize() {
            return this.model.size;
        }
        getTotal() {
            return this.model.total;
        }
        isEnabled() {
            return this.model.enabled;
        }
    };
    PaginationImpl = __decorate([ inversify.injectable(), __param(0, inversify.inject(PaginationModelToken)), __param(1, inversify.inject(PaginationItemFactory)), __metadata("design:paramtypes", [ Object, Function ]) ], PaginationImpl);
    /**
   * Checks whether a value is a pagination.
   * @param value The value to check.
   */    function isPagination(value) {
        return value instanceof PaginationImpl;
    }
    function PageModule() {
        return new inversify.ContainerModule((bind => {
            bind(EventBusService$1).toDynamicValue((() => new emittery.Typed)).inSingletonScope().when((() => typeof window !== "undefined"));
            bind(LinkRewriterService).to(LinkRewriterImpl).inSingletonScope();
            bind(DomParserService).toConstantValue(new xmldom.DOMParser);
            bind(XmlSerializerService).toConstantValue(new xmldom.XMLSerializer);
            bind(ButtonFactory).toSelf().inSingletonScope().onActivation(((context, factory) => factory.register(TYPE_MANAGE_CONTENT_BUTTON, createManageContentButton).register(TYPE_MANAGE_MENU_BUTTON, (menu => menu.getMeta()))));
            bind(LinkFactory).toSelf().inSingletonScope().onActivation((({container}, factory) => {
                const url = container.get(UrlBuilderService);
                return factory.register(TYPE_LINK_INTERNAL, url.getSpaUrl.bind(url));
            }));
            bind(MetaCollectionFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(MetaCollectionImpl).toSelf();
                scope.bind(MetaCollectionModelToken).toConstantValue(model);
                return scope.get(MetaCollectionImpl);
            }));
            bind(MetaFactory).toSelf().inSingletonScope().onActivation(((context, factory) => factory.register(TYPE_META_COMMENT, ((model, position) => new MetaCommentImpl(model, position)))));
            bind(MenuItemFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(MenuItemImpl).toSelf();
                scope.bind(MenuItemModelToken).toConstantValue(model);
                return scope.get(MenuItemImpl);
            }));
            bind(ImageFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(ImageImpl).toSelf();
                scope.bind(ImageModelToken).toConstantValue(model);
                return scope.get(ImageImpl);
            }));
            bind(PaginationItemFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(PaginationItemImpl).toSelf();
                scope.bind(PaginationItemModelToken).toConstantValue(model);
                return scope.get(PaginationItemImpl);
            }));
            bind(ContentFactory).toSelf().inSingletonScope().onActivation((({container}, factory) => factory.register(TYPE_DOCUMENT, (model => {
                const scope = container.createChild();
                scope.bind(DocumentImpl).toSelf();
                scope.bind(DocumentModelToken).toConstantValue(model);
                return scope.get(DocumentImpl);
            })).register(TYPE_IMAGE_SET, (model => {
                const scope = container.createChild();
                scope.bind(ImageSetImpl).toSelf();
                scope.bind(ImageSetModelToken).toConstantValue(model);
                return scope.get(ImageSetImpl);
            })).register(TYPE_MENU, (model => {
                const scope = container.createChild();
                scope.bind(MenuImpl).toSelf();
                scope.bind(MenuModelToken).toConstantValue(model);
                return scope.get(MenuImpl);
            })).register(TYPE_PAGINATION, (model => {
                const scope = container.createChild();
                scope.bind(PaginationImpl).toSelf();
                scope.bind(PaginationModelToken).toConstantValue(model);
                return scope.get(PaginationImpl);
            }))));
            bind(ComponentFactory).toSelf().inSingletonScope().onActivation((({container}, factory) => factory.register(TYPE_COMPONENT, ((model, children) => {
                const scope = container.createChild();
                scope.bind(ComponentImpl).toSelf();
                scope.bind(ComponentModelToken).toConstantValue(model);
                scope.bind(ComponentChildrenToken).toConstantValue(children);
                return scope.get(ComponentImpl);
            })).register(TYPE_COMPONENT_CONTAINER, ((model, children) => {
                const scope = container.createChild();
                scope.bind(ContainerImpl).toSelf();
                scope.bind(ComponentModelToken).toConstantValue(model);
                scope.bind(ComponentChildrenToken).toConstantValue(children);
                return scope.get(ContainerImpl);
            })).register(TYPE_COMPONENT_CONTAINER_ITEM, (model => {
                const scope = container.createChild();
                scope.bind(ContainerItemImpl).toSelf();
                scope.bind(ComponentModelToken).toConstantValue(model);
                return scope.get(ContainerItemImpl);
            }))));
            bind(PageFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(PageImpl).toSelf();
                scope.bind(PageModelToken).toConstantValue(model);
                return scope.get(PageImpl);
            }));
        }));
    }
    function PageModule$1() {
        return new inversify.ContainerModule((bind => {
            bind(EventBusService$1).toDynamicValue((() => new emittery.Typed)).inSingletonScope().when((() => typeof window !== "undefined"));
            bind(LinkRewriterService).to(LinkRewriterImpl).inSingletonScope();
            bind(DomParserService).toConstantValue(new xmldom.DOMParser);
            bind(XmlSerializerService).toConstantValue(new xmldom.XMLSerializer);
            bind(ButtonFactory).toSelf().inSingletonScope().onActivation(((context, factory) => factory.register(TYPE_MANAGE_CONTENT_BUTTON, createManageContentButton).register(TYPE_MANAGE_MENU_BUTTON, (({_meta}) => _meta !== null && _meta !== void 0 ? _meta : {}))));
            bind(LinkFactory).toSelf().inSingletonScope().onActivation((({container}, factory) => {
                const url = container.get(UrlBuilderService);
                return factory.register(TYPE_LINK_INTERNAL, url.getSpaUrl.bind(url));
            }));
            bind(MetaCollectionFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(MetaCollectionImpl).toSelf();
                scope.bind(MetaCollectionModelToken).toConstantValue(model);
                return scope.get(MetaCollectionImpl);
            }));
            bind(MetaFactory).toSelf().inSingletonScope().onActivation(((context, factory) => factory.register(TYPE_META_COMMENT, ((model, position) => new MetaCommentImpl(model, position)))));
            bind(ContentFactory$1).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(ContentImpl).toSelf();
                scope.bind(ContentModelToken).toConstantValue(model);
                return scope.get(ContentImpl);
            }));
            bind(ComponentFactory$1).toSelf().inSingletonScope().onActivation((({container}, factory) => factory.register(TYPE_COMPONENT$1, ((model, children) => {
                const scope = container.createChild();
                scope.bind(ComponentImpl$1).toSelf();
                scope.bind(ComponentModelToken).toConstantValue(model);
                scope.bind(ComponentChildrenToken).toConstantValue(children);
                return scope.get(ComponentImpl$1);
            })).register(TYPE_COMPONENT_CONTAINER$1, ((model, children) => {
                const scope = container.createChild();
                scope.bind(ContainerImpl$1).toSelf();
                scope.bind(ComponentModelToken).toConstantValue(model);
                scope.bind(ComponentChildrenToken).toConstantValue(children);
                return scope.get(ContainerImpl$1);
            })).register(TYPE_COMPONENT_CONTAINER_ITEM$1, (model => {
                const scope = container.createChild();
                scope.bind(ContainerItemImpl$1).toSelf();
                scope.bind(ComponentModelToken).toConstantValue(model);
                return scope.get(ContainerItemImpl$1);
            }))));
            bind(PageFactory).toFactory((({container}) => model => {
                const scope = container.createChild();
                scope.bind(PageImpl$1).toSelf();
                scope.bind(PageModelToken).toConstantValue(model);
                return scope.get(PageImpl$1);
            }));
        }));
    }
    /**
   * Checks whether a value is a page component.
   * @param value The value to check.
   */    function isComponent$2(value) {
        return isComponent(value) || isComponent$1(value);
    }
    /**
   * Checks whether a value is a page container.
   * @param value The value to check.
   */    function isContainer$2(value) {
        return isContainer(value) || isContainer$1(value);
    }
    /**
   * Checks whether a value is a page container item.
   * @param value The value to check.
   */    function isContainerItem$2(value) {
        return isContainerItem(value) || isContainerItem$1(value);
    }
    /**
   * Checks whether a value is a page.
   * @param value The value to check.
   */    function isPage$2(value) {
        return isPage(value) || isPage$1(value);
    }
    const SpaService = Symbol.for("SpaService");
    /**
   * SPA entry point interacting with the Channel Manager and the Page Model API.
   */    let Spa = class Spa {
        /**
     * @param eventBus Event bus to exchange data between submodules.
     * @param api Api client.
     * @param pageFactory Factory to produce page instances.
     */
        constructor(api, pageFactory, cmsEventBus, eventBus) {
            this.api = api;
            this.pageFactory = pageFactory;
            this.cmsEventBus = cmsEventBus;
            this.eventBus = eventBus;
            this.onCmsUpdate = this.onCmsUpdate.bind(this);
        }
        onCmsUpdate(event) {
            var _a;
            return __awaiter(this, void 0, void 0, (function*() {
                const root = this.page.getComponent();
                const component = root.getComponentById(event.id);
                const url = component === null || component === void 0 ? void 0 : component.getUrl();
                if (!url) {
                    return;
                }
                const model = yield this.api.getComponent(url, event.properties);
                (_a = this.eventBus) === null || _a === void 0 ? void 0 : _a.emit("page.update", {
                    page: model
                });
            }));
        }
        /**
     * Initializes the SPA.
     * @param model A preloaded page model or URL to a page model.
     */        initialize(model) {
            if (typeof model === "string") {
                return this.api.getPage(model).then(this.hydrate.bind(this));
            }
            return this.hydrate(model);
        }
        hydrate(model) {
            var _a;
            this.page = this.pageFactory(model);
            if (this.page.isPreview()) {
                (_a = this.cmsEventBus) === null || _a === void 0 ? void 0 : _a.on("cms.update", this.onCmsUpdate);
            }
            return this.page;
        }
        /**
     * Destroys the integration with the SPA page.
     */        destroy() {
            var _a, _b;
            (_a = this.cmsEventBus) === null || _a === void 0 ? void 0 : _a.off("cms.update", this.onCmsUpdate);
            (_b = this.eventBus) === null || _b === void 0 ? void 0 : _b.clearListeners();
            delete this.page;
        }
    };
    Spa = __decorate([ inversify.injectable(), __param(0, inversify.inject(ApiService)), __param(1, inversify.inject(PageFactory)), __param(2, inversify.inject(EventBusService)), __param(2, inversify.optional()), __param(3, inversify.inject(EventBusService$1)), __param(3, inversify.optional()), __metadata("design:paramtypes", [ Object, Function, Object, Object ]) ], Spa);
    function SpaModule() {
        return new inversify.ContainerModule((bind => {
            bind(ApiService).to(ApiImpl).inSingletonScope();
            bind(SpaService).to(Spa).inSingletonScope();
        }));
    }
    function isConfigurationWithProxy(value) {
        var _a, _b;
        return !!(((_a = value === null || value === void 0 ? void 0 : value.options) === null || _a === void 0 ? void 0 : _a.live) && ((_b = value === null || value === void 0 ? void 0 : value.options) === null || _b === void 0 ? void 0 : _b.preview));
    }
    function isConfigurationWithJwt09(value) {
        return !!(value === null || value === void 0 ? void 0 : value.cmsBaseUrl);
    }
    const DEFAULT_AUTHORIZATION_PARAMETER = "token";
    const DEFAULT_SERVER_ID_PARAMETER = "server-id";
    const container = new inversify.Container({
        skipBaseClassChecks: true
    });
    const pages = new WeakMap;
    container.load(CmsModule(), UrlModule());
    function onReady(value, callback) {
        const wrapper = result => (callback(result), result);
        return value instanceof Promise ? value.then(wrapper) : wrapper(value);
    }
    function initializeWithProxy(scope, configuration, model) {
        const options = isMatched(configuration.request.path, configuration.options.preview.spaBaseUrl) ? configuration.options.preview : configuration.options.live;
        scope.load(PageModule$1(), SpaModule(), UrlModule$1());
        scope.bind(ApiOptionsToken).toConstantValue(configuration);
        scope.bind(UrlBuilderOptionsToken).toConstantValue(options);
        scope.getNamed(CmsService, "cms14").initialize(configuration);
        return onReady(scope.get(SpaService).initialize(model !== null && model !== void 0 ? model : configuration.request.path), (() => {
            scope.unbind(ApiOptionsToken);
            scope.unbind(UrlBuilderOptionsToken);
        }));
    }
    function initializeWithJwt09(scope, configuration, model) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const authorizationParameter = (_a = configuration.authorizationQueryParameter) !== null && _a !== void 0 ? _a : DEFAULT_AUTHORIZATION_PARAMETER;
        const serverIdParameter = (_b = configuration.serverIdQueryParameter) !== null && _b !== void 0 ? _b : DEFAULT_SERVER_ID_PARAMETER;
        const {url: path, searchParams} = extractSearchParams(configuration.request.path, [ authorizationParameter, serverIdParameter ].filter(Boolean));
        const authorizationToken = (_c = searchParams.get(authorizationParameter)) !== null && _c !== void 0 ? _c : undefined;
        const serverId = (_d = searchParams.get(serverIdParameter)) !== null && _d !== void 0 ? _d : undefined;
        const config = _extends(_extends({}, configuration), {
            origin: (_e = configuration.origin) !== null && _e !== void 0 ? _e : parseUrl((_g = (_f = configuration.apiBaseUrl) !== null && _f !== void 0 ? _f : configuration.cmsBaseUrl) !== null && _g !== void 0 ? _g : "").origin,
            spaBaseUrl: appendSearchParams((_h = configuration.spaBaseUrl) !== null && _h !== void 0 ? _h : "", searchParams)
        });
        scope.load(PageModule$1(), SpaModule(), UrlModule$1());
        scope.bind(ApiOptionsToken).toConstantValue(_extends({
            authorizationToken,
            serverId
        }, config));
        scope.bind(UrlBuilderOptionsToken).toConstantValue(config);
        return onReady(scope.get(SpaService).initialize(model !== null && model !== void 0 ? model : path), (page => {
            if (page.isPreview() && config.cmsBaseUrl) {
                scope.get(PostMessageService).initialize(config);
                scope.get(CmsService).initialize(config);
            }
            scope.unbind(ApiOptionsToken);
            scope.unbind(UrlBuilderOptionsToken);
        }));
    }
    function initializeWithJwt10(scope, configuration, model) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const authorizationParameter = (_a = configuration.authorizationQueryParameter) !== null && _a !== void 0 ? _a : DEFAULT_AUTHORIZATION_PARAMETER;
        const endpointParameter = (_b = configuration.endpointQueryParameter) !== null && _b !== void 0 ? _b : "";
        const serverIdParameter = (_c = configuration.serverIdQueryParameter) !== null && _c !== void 0 ? _c : DEFAULT_SERVER_ID_PARAMETER;
        const {url: path, searchParams} = extractSearchParams(configuration.request.path, [ authorizationParameter, serverIdParameter, endpointParameter ].filter(Boolean));
        const authorizationToken = (_d = searchParams.get(authorizationParameter)) !== null && _d !== void 0 ? _d : undefined;
        const endpoint = (_e = searchParams.get(endpointParameter)) !== null && _e !== void 0 ? _e : undefined;
        const serverId = (_f = searchParams.get(serverIdParameter)) !== null && _f !== void 0 ? _f : undefined;
        const config = _extends(_extends({}, configuration), {
            apiVersion: "1.0",
            endpoint: (_g = configuration.endpoint) !== null && _g !== void 0 ? _g : endpoint,
            baseUrl: appendSearchParams((_h = configuration.baseUrl) !== null && _h !== void 0 ? _h : "", searchParams),
            origin: (_j = configuration.origin) !== null && _j !== void 0 ? _j : parseUrl((_l = (_k = configuration.endpoint) !== null && _k !== void 0 ? _k : endpoint) !== null && _l !== void 0 ? _l : "").origin
        });
        scope.load(PageModule(), SpaModule(), UrlModule());
        scope.bind(ApiOptionsToken).toConstantValue(_extends({
            authorizationToken,
            serverId
        }, config));
        scope.bind(UrlBuilderOptionsToken).toConstantValue(config);
        return onReady(scope.get(SpaService).initialize(model !== null && model !== void 0 ? model : path), (page => {
            if (page.isPreview() && config.endpoint) {
                scope.get(PostMessageService).initialize(config);
                scope.get(CmsService).initialize(config);
            }
            scope.unbind(ApiOptionsToken);
            scope.unbind(UrlBuilderOptionsToken);
        }));
    }
    function initialize(configuration, model) {
        if (isPage$2(model)) {
            return model;
        }
        const scope = container.createChild();
        return onReady(isConfigurationWithProxy(configuration) ? initializeWithProxy(scope, configuration, model) : isConfigurationWithJwt09(configuration) ? initializeWithJwt09(scope, configuration, model) : initializeWithJwt10(scope, configuration, model), (page => pages.set(page, scope)));
    }
    /**
   * Destroys the integration with the SPA page.
   * @param page Page instance to destroy.
   */    function destroy(page) {
        const scope = pages.get(page);
        pages.delete(page);
        return scope === null || scope === void 0 ? void 0 : scope.get(SpaService).destroy();
    }
    exports.META_POSITION_BEGIN = META_POSITION_BEGIN;
    exports.META_POSITION_END = META_POSITION_END;
    exports.TYPE_CONTAINER_BOX = TYPE_CONTAINER_BOX;
    exports.TYPE_CONTAINER_INLINE = TYPE_CONTAINER_INLINE;
    exports.TYPE_CONTAINER_NO_MARKUP = TYPE_CONTAINER_NO_MARKUP;
    exports.TYPE_CONTAINER_ORDERED_LIST = TYPE_CONTAINER_ORDERED_LIST;
    exports.TYPE_CONTAINER_UNORDERED_LIST = TYPE_CONTAINER_UNORDERED_LIST;
    exports.TYPE_LINK_EXTERNAL = TYPE_LINK_EXTERNAL;
    exports.TYPE_LINK_INTERNAL = TYPE_LINK_INTERNAL;
    exports.TYPE_LINK_RESOURCE = TYPE_LINK_RESOURCE;
    exports.TYPE_MANAGE_CONTENT_BUTTON = TYPE_MANAGE_CONTENT_BUTTON;
    exports.TYPE_MANAGE_MENU_BUTTON = TYPE_MANAGE_MENU_BUTTON;
    exports.destroy = destroy;
    exports.initialize = initialize;
    exports.isComponent = isComponent$2;
    exports.isContainer = isContainer$2;
    exports.isContainerItem = isContainerItem$2;
    exports.isContent = isContent;
    exports.isDocument = isDocument;
    exports.isImageSet = isImageSet;
    exports.isLink = isLink;
    exports.isMenu = isMenu;
    exports.isMeta = isMeta;
    exports.isMetaComment = isMetaComment;
    exports.isPage = isPage$2;
    exports.isPagination = isPagination;
    exports.isReference = isReference;
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
}));
//# sourceMappingURL=index.js.map
